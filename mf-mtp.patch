--- system/vold/CommandListener.cpp
+++ system/vold/CommandListener.cpp
@@ -12,6 +12,41 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *  
+ * 
+ * This file was modified from the original project to implement the Mobiflage
+ * plausible deniable storage encryption functionality by Adam Skillen.
+ *   
+ * Copyright (C) 2013 Adam Skillen
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *      This product includes software developed by Adam Skillen
+ * 4. Neither the name of Concordia University, Mobiflage, nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *  
  */
 
 #include <stdlib.h>
@@ -575,7 +610,17 @@
         }
         dumpArgs(argc, argv, -1);
         rc = cryptfs_crypto_complete();
-    } else if (!strcmp(argv[1], "enablecrypto")) {
+        
+    /* ADAM PDE : Added cli option to enable pde */
+    } else if (!strcmp(argv[1], "pde")) {
+        if ( (argc != 5) || (strcmp(argv[2], "wipe") && strcmp(argv[2], "inplace")) ) {
+            cli->sendMsg(ResponseCode::CommandSyntaxError, "Usage: cryptfs pde <wipe|inplace> <passwd_outer> <passwd_hidden>", false);
+            return 0;
+        }
+        SLOGD("cryptfs enablecrypto %s {}", argv[2]);
+        rc = cryptfs_enable_pde(argv[2], argv[3], argv[4]);
+        
+    }else if (!strcmp(argv[1], "enablecrypto")) {
         if ( (argc != 4) || (strcmp(argv[2], "wipe") && strcmp(argv[2], "inplace")) ) {
             cli->sendMsg(ResponseCode::CommandSyntaxError, "Usage: cryptfs enablecrypto <wipe|inplace> <passwd>", false);
             return 0;
             
             
--- system/vold/cryptfs.c
+++ system/vold/cryptfs.c
@@ -12,6 +12,41 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *  
+ * 
+ * This file was modified from the original project to implement the Mobiflage
+ * plausible deniable storage encryption functionality by Adam Skillen.
+ *   
+ * Copyright (C) 2013 Adam Skillen
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *      This product includes software developed by Adam Skillen
+ * 4. Neither the name of Concordia University, Mobiflage, nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *  
  */
 
 /* TO DO:
@@ -50,9 +85,9 @@
 #define DM_CRYPT_BUF_SIZE 4096
 #define DATA_MNT_POINT "/data"
 
-#define HASH_COUNT 2000
-#define KEY_LEN_BYTES 16
-#define IV_LEN_BYTES 16
+#define HASH_COUNT 20000
+#define KEY_LEN_BYTES 64
+#define IV_LEN_BYTES 32
 
 #define KEY_IN_FOOTER  "footer"
 
@@ -64,6 +99,7 @@
 char *me = "cryptfs";
 
 static unsigned char saved_master_key[KEY_LEN_BYTES];
+static off64_t g_pdeoff = 0;
 static char *saved_data_blkdev;
 static char *saved_mount_point;
 static int  master_key_saved = 0;
@@ -377,8 +413,11 @@
 
 }
 
+/* ADAM PDE
+ * Added offset parameter for PDE devices
+ */
 static int create_crypto_blk_dev(struct crypt_mnt_ftr *crypt_ftr, unsigned char *master_key,
-                                    char *real_blk_name, char *crypto_blk_name, const char *name)
+                                    char *real_blk_name, char *crypto_blk_name, const char *name, off64_t offset)
 {
   char buffer[DM_CRYPT_BUF_SIZE];
   char master_key_ascii[129]; /* Large enough to hold 512 bit key and null */
@@ -419,13 +458,16 @@
   io->target_count = 1;
   tgt->status = 0;
   tgt->sector_start = 0;
-  tgt->length = crypt_ftr->fs_size;
+  tgt->length = crypt_ftr->fs_size - offset;    /* ADAM PDE : subtract offset from disk size */
   strcpy(tgt->target_type, "crypt");
 
   crypt_params = buffer + sizeof(struct dm_ioctl) + sizeof(struct dm_target_spec);
   convert_key_to_hex_ascii(master_key, crypt_ftr->keysize, master_key_ascii);
-  sprintf(crypt_params, "%s %s 0 %s 0", crypt_ftr->crypto_type_name,
-          master_key_ascii, real_blk_name);
+   
+  /* ADAM PDE: Last dm-crypt param must be offset to hidden volume start   */
+  sprintf(crypt_params, "%s %s 0 %s %lld", crypt_ftr->crypto_type_name,
+          master_key_ascii, real_blk_name, offset);
+          
   crypt_params += strlen(crypt_params) + 1;
   crypt_params = (char *) (((unsigned long)crypt_params + 7) & ~8); /* Align to an 8 byte boundary */
   tgt->next = crypt_params - buffer;
@@ -494,15 +536,16 @@
 static void pbkdf2(char *passwd, unsigned char *salt, unsigned char *ikey)
 {
     /* Turn the password into a key and IV that can decrypt the master key */
+    /* ADAM PDE : changed length to IV_LEN + IV_LEN since KEY_LEN in 64B but we want 32B for CBC */
     PKCS5_PBKDF2_HMAC_SHA1(passwd, strlen(passwd), salt, SALT_LEN,
-                           HASH_COUNT, KEY_LEN_BYTES+IV_LEN_BYTES, ikey);
+                           HASH_COUNT, IV_LEN_BYTES+IV_LEN_BYTES, ikey);
 }
 
 static int encrypt_master_key(char *passwd, unsigned char *salt,
                               unsigned char *decrypted_master_key,
                               unsigned char *encrypted_master_key)
 {
-    unsigned char ikey[32+32] = { 0 }; /* Big enough to hold a 256 bit key and 256 bit IV */
+    unsigned char ikey[IV_LEN_BYTES+IV_LEN_BYTES] = { 0 }; /* Big enough to hold a 256 bit key and 256 bit IV */
     EVP_CIPHER_CTX e_ctx;
     int encrypted_len, final_len;
 
@@ -510,7 +553,8 @@
     pbkdf2(passwd, salt, ikey);
   
     /* Initialize the decryption engine */
-    if (! EVP_EncryptInit(&e_ctx, EVP_aes_128_cbc(), ikey, ikey+KEY_LEN_BYTES)) {
+    /* ADAM PDE : Still using CBC for master key encryption since watermarking is not an issue here */
+    if (! EVP_EncryptInit(&e_ctx, EVP_aes_256_cbc(), ikey, ikey+IV_LEN_BYTES)) {
         SLOGE("EVP_EncryptInit failed\n");
         return -1;
     }
@@ -539,7 +583,7 @@
                               unsigned char *encrypted_master_key,
                               unsigned char *decrypted_master_key)
 {
-  unsigned char ikey[32+32] = { 0 }; /* Big enough to hold a 256 bit key and 256 bit IV */
+  unsigned char ikey[IV_LEN_BYTES+IV_LEN_BYTES] = { 0 }; /* Big enough to hold a 256 bit key and 256 bit IV */
   EVP_CIPHER_CTX d_ctx;
   int decrypted_len, final_len;
 
@@ -547,7 +591,7 @@
   pbkdf2(passwd, salt, ikey);
 
   /* Initialize the decryption engine */
-  if (! EVP_DecryptInit(&d_ctx, EVP_aes_128_cbc(), ikey, ikey+KEY_LEN_BYTES)) {
+  if (! EVP_DecryptInit(&d_ctx, EVP_aes_256_cbc(), ikey, ikey+IV_LEN_BYTES)) {
     return -1;
   }
   EVP_CIPHER_CTX_set_padding(&d_ctx, 0); /* Turn off padding as our data is block aligned */
@@ -646,6 +690,31 @@
     }
 }
 
+/* ADAM PDE : Calculate the offset for the hidden volume from the device serial */
+off64_t calc_hidden_size(unsigned char *salt, off64_t vol_size)
+{
+	unsigned char ikey[KEY_LEN_BYTES];
+	unsigned long long off;
+	unsigned long long *ull;
+	char serialno[PROPERTY_VALUE_MAX];
+
+	// get device serialno
+	property_get("ro.serialno", serialno, "");
+	
+	ull = ikey;
+	pbkdf2(serialno, salt, ikey);
+	
+
+	off = (*ull % (vol_size/4)) + (vol_size/4);
+    
+	
+	//off must be multiple of 8
+	off = off / 8;
+	off = off * 8;
+	
+	return (off64_t) off;
+}
+
 int cryptfs_restart(void)
 {
     char fs_type[32];
@@ -733,7 +802,7 @@
 static int do_crypto_complete(char *mount_point)
 {
   struct crypt_mnt_ftr crypt_ftr;
-  unsigned char encrypted_master_key[32];
+  unsigned char encrypted_master_key[KEY_LEN_BYTES];
   unsigned char salt[SALT_LEN];
   char real_blkdev[MAXPATHLEN];
   char encrypted_state[PROPERTY_VALUE_MAX];
@@ -776,19 +845,78 @@
   return 0;
 }
 
+
+
+// this helper function is from kernel ext4 fs driver
+static inline int test_root(int a, int b)
+{
+    int num = b;
+
+    while (a > num)
+        num *= b;
+    return num == a;
+}
+
+// this helper function is from kernel ext4 fs driver
+static int group_sparse(int group)
+{
+    if (group <= 1)
+        return 1;
+    if (!(group & 1))
+        return 0;
+    return (test_root(group, 7) || test_root(group, 5) ||
+        test_root(group, 3));
+}
+
+// Given a blk num, determine if it collides with outer volume meta-data blocks
+// returns 0 for a good block, and the blk_num of the next good block if cur_blk is bad
+static off64_t cryptfs_is_badblk(off64_t cur_blk)
+{
+    int cur_bg, cur_bg_i;
+    char cmdline[256];
+    char buf[4096];
+    int rc = -1;
+    
+    // determine cur_blk's bg_num, and index within bg (knowing that bs=4096 and blk/grp=32768)
+    cur_bg = (cur_blk > 0)? 1 + (cur_blk - 1)/32768: (cur_blk / 32768); // round-up integer division
+    cur_bg_i = cur_blk % 32768;
+   
+    // check if cur_bg is sparse
+    if (group_sparse(cur_bg)) {
+        // it is, so the first 516 blocks are bad
+        if (cur_bg_i <= 516) {
+            return (cur_bg * 32768) + 517;
+        } else {
+            return 0;
+        }
+    } else {
+        // it isn't, so the first 514 blocks are bad
+        if (cur_bg_i < 514) {
+            return (cur_bg * 32768) + 515;
+        } else {
+            return 0;
+        }
+    }
+}
+
+
 static int test_mount_encrypted_fs(char *passwd, char *mount_point, char *label)
 {
   struct crypt_mnt_ftr crypt_ftr;
   /* Allocate enough space for a 256 bit key, but we may use less */
-  unsigned char encrypted_master_key[32], decrypted_master_key[32];
+  unsigned char encrypted_master_key[KEY_LEN_BYTES], decrypted_master_key[KEY_LEN_BYTES];
   unsigned char salt[SALT_LEN];
   char crypto_blkdev[MAXPATHLEN];
   char real_blkdev[MAXPATHLEN];
   char tmp_mount_point[64];
-  unsigned int orig_failed_decrypt_count;
+  unsigned int orig_failed_decrypt_count, cnt;
   char encrypted_state[PROPERTY_VALUE_MAX];
-  int rc;
-
+  int rc, i, ret;
+  off64_t pde_size, size;
+  off64_t off=0;
+  off64_t cur_blk, cln_blk;
+  int fd;
+  
   property_get("ro.crypto.state", encrypted_state, "");
   if ( master_key_saved || strcmp(encrypted_state, "encrypted") ) {
     SLOGE("encrypted fs already validated or not running with encryption, aborting");
@@ -810,7 +938,7 @@
   }
 
   if (create_crypto_blk_dev(&crypt_ftr, decrypted_master_key,
-                               real_blkdev, crypto_blkdev, label)) {
+                               real_blkdev, crypto_blkdev, label, 0)) {
     SLOGE("Error creating decrypted block device\n");
     return -1;
   }
@@ -825,11 +953,109 @@
   sprintf(tmp_mount_point, "%s/tmp_mnt", mount_point);
   mkdir(tmp_mount_point, 0755);
   if (fs_mgr_do_mount(get_fstab_filename(), DATA_MNT_POINT, crypto_blkdev, tmp_mount_point)) {
-    SLOGE("Error temp mounting decrypted block device\n");
-    delete_crypto_blk_dev(label);
-    crypt_ftr.failed_decrypt_count++;
+        /* ADAM PDE -- Failed to mount outer volume... try PDE before giving up */
+
+        //delete dm-crypt mapping
+        delete_crypto_blk_dev(label);
+
+        // look for a PDE partition  
+        fd = open(real_blkdev, O_RDONLY);
+
+        // get real block device size
+        if ((size = get_blkdev_size(fd)) == 0) {
+            return -1;
+        }
+
+        // get pde partition size
+        pde_size = calc_hidden_size(salt, size);
+
+        // clac offset to pde volume
+        off = size - pde_size;
+
+ 
+    
+        // walk the fs blocks until we find the clean offset
+        do {
+
+            // get blk_num of the current offset
+            cur_blk = ((off * 512) / 4096);
+            
+            for (i=0; i<4; i++) {
+            
+                if ((cln_blk = cryptfs_is_badblk(cur_blk))) {
+                    // block is bad, cln_blk has the index of the next clean block
+                    
+                    // adjust offset to cln_blk
+                    off = (cln_blk * 4096) / 512;
+                    
+                    // adjust pde volume size to account for new offset
+                    pde_size = size - off;
+                    
+                    // continue while loop if we found a bad block
+                    break;
+                    
+                } // else block was clean
+            
+            }
+
+        } while(cln_blk);
+    
+    
+        // seek to pde key location             
+        if (lseek64(fd, off*512, SEEK_SET) == -1) {
+          //SLOGE("Cannot seek to real block device PDE Key\n");
+          return -1;
+        }
+
+        // read pde key from disk
+        if ((cnt = read(fd, encrypted_master_key, sizeof(encrypted_master_key))) != sizeof(encrypted_master_key)) {
+	        //SLOGE("Cannot read real block device PDE key\n");
+	        return -1;
+        }
+
+        // close real block device
+        close(fd);
+			
+		// get pde master volume key
+        decrypt_master_key(passwd, salt, encrypted_master_key, decrypted_master_key);
+
+        // setup crypto mapping for pde volume
+        // NOTE: using off+8 to block align hidden volume w/ outer volume and account for key
+        if (create_crypto_blk_dev(&crypt_ftr, decrypted_master_key,
+                       real_blkdev, crypto_blkdev, label, off+8)) {
+	        //SLOGE("Error creating decrypted block device\n");
+	        return -1;
+        }
+		
+		// try to mount the pde filesystem   
+        if (fs_mgr_do_mount(get_fstab_filename(), DATA_MNT_POINT, crypto_blkdev, tmp_mount_point)) {
+	        // failed to mount, tear everything down
+	        //SLOGE("Error temp mounting decrypted block device\n");
+	        //g_pde_size = 0;
+	        delete_crypto_blk_dev(label);
+	        crypt_ftr.failed_decrypt_count++;
+        } else {
+	        /* Success for PDE */
+	        g_pdeoff = off;
+	        umount(tmp_mount_point);
+	        crypt_ftr.failed_decrypt_count  = 0;
+	
+	        /* Now umount cache and remount a tmpfs */
+	        wait_and_unmount("/cache");	
+	        mount("tmpfs", "/cache", "tmpfs", MS_NOATIME | MS_NOSUID | MS_NODEV, "size=32m");
+	        // fs_mgr_do_tmpfs_mount("/cache");
+
+
+	        // If this device has a persistent log partition, mount a tmpfs
+			if (!access("/devlog", F_OK)) {
+	            wait_and_unmount("/devlog");
+	            mount("tmpfs", "/devlog", "tmpfs", MS_NOATIME | MS_NOSUID | MS_NODEV, "size=8m");  
+	            // fs_mgr_do_tmpfs_mount("/devlog");
+        	}
+        }
+    
   } else {
-    /* Success, so just umount and we'll mount it properly when we restart
+    /* Success (outer), so just umount and we'll mount it properly when we restart
      * the framework.
      */
     umount(tmp_mount_point);
@@ -883,10 +1109,11 @@
 {
     char real_blkdev[MAXPATHLEN], crypto_blkdev[MAXPATHLEN];
     struct crypt_mnt_ftr sd_crypt_ftr;
-    unsigned char key[32], salt[32];
+    unsigned char key[KEY_LEN_BYTES], salt[SALT_LEN];
     struct stat statbuf;
     int nr_sec, fd;
-
+    off64_t pde_off = 0;
+    
     sprintf(real_blkdev, "/dev/block/vold/%d:%d", major, minor);
 
     /* Just want the footer, but gotta get it all */
@@ -902,8 +1129,9 @@
     }
 
     sd_crypt_ftr.fs_size = nr_sec;
+	
     create_crypto_blk_dev(&sd_crypt_ftr, saved_master_key, real_blkdev, 
-                          crypto_blkdev, label);
+                          crypto_blkdev, label, 0);
 
     stat(crypto_blkdev, &statbuf);
     *new_major = MAJOR(statbuf.st_rdev);
@@ -929,15 +1157,16 @@
     return rc;
 }
 
+        
 int cryptfs_verify_passwd(char *passwd)
 {
     struct crypt_mnt_ftr crypt_ftr;
     /* Allocate enough space for a 256 bit key, but we may use less */
-    unsigned char encrypted_master_key[32], decrypted_master_key[32];
+    unsigned char encrypted_master_key[KEY_LEN_BYTES], decrypted_master_key[KEY_LEN_BYTES];
     unsigned char salt[SALT_LEN];
     char real_blkdev[MAXPATHLEN];
     char encrypted_state[PROPERTY_VALUE_MAX];
-    int rc;
+    int rc, fd, cnt;
 
     property_get("ro.crypto.state", encrypted_state, "");
     if (strcmp(encrypted_state, "encrypted") ) {
@@ -957,16 +1186,48 @@
 
     fs_mgr_get_crypt_info(get_fstab_filename(), 0, real_blkdev, sizeof(real_blkdev));
 
-    if (get_crypt_ftr_and_key(real_blkdev, &crypt_ftr, encrypted_master_key, salt)) {
+	if (get_crypt_ftr_and_key(real_blkdev, &crypt_ftr, encrypted_master_key, salt)) {
         SLOGE("Error getting crypt footer and key\n");
         return -1;
-    }
+	}
+
+
+	/* ADAM PDE: check if we are mounted in hidden volume */
+	if (g_pdeoff) {
+
+
+		// Open real block device for writing
+		if ( (fd = open(real_blkdev, O_RDONLY)) < 0) {
+		  //SLOGE("Cannot open real block device\n");
+		  return -1;
+		}
+
+        // seek to pde key location             
+        if (lseek64(fd, g_pdeoff*512, SEEK_SET) == -1) {
+          //SLOGE("Cannot seek to real block device PDE Key\n");
+          return -1;
+        }
+
+        // read pde key from disk
+        if ((cnt = read(fd, encrypted_master_key, sizeof(encrypted_master_key))) != sizeof(encrypted_master_key)) {
+	        //SLOGE("Cannot read real block device PDE key\n");
+	        return -1;
+        }
+
+        // close real block device
+        close(fd);
+		
+
+	}
+	
+	decrypt_master_key(passwd, salt, encrypted_master_key, decrypted_master_key);
+	
 
     if (crypt_ftr.flags & CRYPT_MNT_KEY_UNENCRYPTED) {
         /* If the device has no password, then just say the password is valid */
         rc = 0;
     } else {
-        decrypt_master_key(passwd, salt, encrypted_master_key, decrypted_master_key);
+        
         if (!memcmp(decrypted_master_key, saved_master_key, crypt_ftr.keysize)) {
             /* They match, the password is correct */
             rc = 0;
@@ -999,29 +1260,145 @@
     ftr->crypto_type_name[0] = '\0';
 }
 
+
+/* Given an offset and volume size, calculate the meta-data blocks and format the hidden volume
+ * HERE offset is the PDE offset, and size is the outer volume size
+ */
+static int cryptfs_calc_badblk(char *crypto_blkdev, off64_t offset, off64_t size)
+{
+    int group, block, num_bg, fd_bb, bb_i;
+    char cmdline[256];
+    char buf[4096];
+    int rc = -1;
+
+// create a bb file in the RAM disk /data directory
+    if ( (fd_bb = open("/data/bb", O_RDWR|O_CREAT, 0600)) < 0) { 
+        SLOGE("Error opening bad blocks file");
+        return -1;
+    }
+
+// determine num_bg based on outer volume size, knowing that bs=4096 and blk/grp=32768
+    num_bg = ((size * 512) / 4096) / 32768;
+    if ((((size * 512) / 4096) % 32768) > 0)
+        num_bg++;
+
+    //FIXME: DEBUGGING ONLY
+    //SLOGI("PDE: num blk grps in outer: %d\n", num_bg);        
+    //SLOGI("PDE: hidden offset, in blocks: %d\n", ((offset * 512) / 4096));           
+        
+
+// iterate over each group, and test for sparse_super
+    for (group = 0; group < num_bg; group++) {
+
+        // if group is a sparse group, then mark 516 bad blocks, otherwise mark 514
+        if (group_sparse(group)) {
+            for (block = 0; block < 516; block++) {
+                bb_i =  (group * 32768) + block - ((offset * 512) / 4096);
+                if (bb_i < 0)
+                    continue;
+                snprintf(buf, sizeof(buf), "%d\n", bb_i);
+                
+                    //FIXME: DEBUGGING ONLY
+                    //SLOGI("PDE: bad block at %d outer: %s hidden\n", ((group * 32768) + block), buf);
+
+                if (write(fd_bb, buf, strlen(buf)) != strlen(buf)) {
+                    //SLOGE("Failed to write to bad blocks file");
+                }
+            }
+        } else {
+            for (block = 0; block < 514; block++) {
+                bb_i =  (group * 32768) + block - ((offset * 512) / 4096);
+                if (bb_i < 0)
+                    continue;
+                snprintf(buf, sizeof(buf), "%d\n", bb_i);
+                
+                    //FIXME: DEBUGGING ONLY
+                    //SLOGI("PDE: bad block at %d outer: %s hidden\n", ((group * 32768) + block), buf);
+                
+                if (write(fd_bb, buf, strlen(buf)) != strlen(buf)) {
+                    //SLOGE("Failed to write to bad blocks file");
+                }
+            }
+        }
+
+    }
+
+    close(fd_bb);
+    
+    
+// format hidden volume
+
+        snprintf(cmdline, sizeof(cmdline), "/system/bin/mke2fs -M /data -m 0 -t ext4 -b 4096 -g 32768 -O ^flex_bg,has_journal,^resize_inode,filetype,extent,sparse_super,large_file,^dir_index,^dir_nlink,^extra_isize,^ext_attr,^huge_file,^uninit_bg -l /data/bb %s",
+                 crypto_blkdev);
+        SLOGI("Making empty filesystem with command %s\n", cmdline);
+        
+        if (system(cmdline)) {
+          SLOGE("Error creating empty filesystem on %s with command %s\nError: %s\n", crypto_blkdev, cmdline, strerror(errno));
+        } else {
+          SLOGD("Successfully created empty filesystem on %s\n", crypto_blkdev);
+          rc = 0;
+        }
+        
+        snprintf(cmdline, sizeof(cmdline), "/system/bin/tune2fs -o ^user_xattr,^acl -e remount-ro -E hash_alg=tea %s", crypto_blkdev);
+        SLOGI("Tuning filesystem with command %s\n", cmdline);
+        
+        if (system(cmdline)) {
+          SLOGE("Error tuning filesystem on %s with command %s\nError: %s\n", crypto_blkdev, cmdline, strerror(errno));
+        } else {
+          SLOGD("Successfully tuned filesystem on %s\n", crypto_blkdev);
+          rc = 0;
+        }
+
+    return rc;
+    
+}
+
+
+
 static int cryptfs_enable_wipe(char *crypto_blkdev, off64_t size, int type)
 {
     char cmdline[256];
     int rc = -1;
 
+/* IF EXT4 */
     if (type == EXT4_FS) {
-        snprintf(cmdline, sizeof(cmdline), "/system/bin/make_ext4fs -a /data -l %lld %s",
-                 size * 512, crypto_blkdev);
+        snprintf(cmdline, sizeof(cmdline), "/system/bin/mke2fs -M /data -m 0 -t ext4 -b 4096 -g 32768 -O ^flex_bg,has_journal,^resize_inode,filetype,extent,sparse_super,large_file,^dir_index,^dir_nlink,^extra_isize,^ext_attr,^huge_file,^uninit_bg %s",
+                 crypto_blkdev);
         SLOGI("Making empty filesystem with command %s\n", cmdline);
+        
+        if (system(cmdline)) {
+          SLOGE("Error creating empty filesystem on %s with command %s\nError: %s\n", crypto_blkdev, cmdline, strerror(errno));
+        } else {
+          SLOGD("Successfully created empty filesystem on %s\n", crypto_blkdev);
+          rc = 0;
+        }
+        
+	snprintf(cmdline, sizeof(cmdline), "/system/bin/tune2fs -o ^user_xattr,^acl -e remount-ro -E hash_alg=tea %s", crypto_blkdev);
+        SLOGI("Tuning filesystem with command %s\n", cmdline);
+        
+        if (system(cmdline)) {
+          SLOGE("Error tuning filesystem on %s with command %s\nError: %s\n", crypto_blkdev, cmdline, strerror(errno));
+        } else {
+          SLOGD("Successfully tuned filesystem on %s\n", crypto_blkdev);
+          rc = 0;
+        }
+        
+/* IF FAT */
     } else if (type== FAT_FS) {
         snprintf(cmdline, sizeof(cmdline), "/system/bin/newfs_msdos -F 32 -O android -c 8 -s %lld %s",
                  size, crypto_blkdev);
         SLOGI("Making empty filesystem with command %s\n", cmdline);
+        
+            if (system(cmdline)) {
+          SLOGE("Error creating empty filesystem on %s with command %s\nError: %s\n", crypto_blkdev, cmdline, strerror(errno));
+        } else {
+          SLOGD("Successfully created empty filesystem on %s\n", crypto_blkdev);
+          rc = 0;
+        }
+        
     } else {
         SLOGE("cryptfs_enable_wipe(): unknown filesystem type %d\n", type);
         return -1;
-    }
-
-    if (system(cmdline)) {
-      SLOGE("Error creating empty filesystem on %s\n", crypto_blkdev);
-    } else {
-      SLOGD("Successfully created empty filesystem on %s\n", crypto_blkdev);
-      rc = 0;
     }
 
     return rc;
@@ -1138,6 +1515,8 @@
     unsigned long nr_sec;
     unsigned char master_key[KEY_LEN_BYTES], decrypted_master_key[KEY_LEN_BYTES];
     unsigned char salt[SALT_LEN];
+    int urandom_fd;
+    unsigned char shred_key[KEY_LEN_BYTES];
     int rc=-1, fd, i, ret;
     struct crypt_mnt_ftr crypt_ftr, sd_crypt_ftr;;
     char tmpfs_options[PROPERTY_VALUE_MAX];
@@ -1157,6 +1536,13 @@
         goto error_unencrypted;
     }
 
+	// If this device has a persistent log partition, mount a tmpfs
+	if (!access("/devlog", F_OK)) {
+		wait_and_unmount("/devlog");
+		mount("tmpfs", "/devlog", "tmpfs", MS_NOATIME | MS_NOSUID | MS_NODEV, "size=8m");  
+		// fs_mgr_do_tmpfs_mount("/devlog");
+	}
+
     fs_mgr_get_crypt_info(get_fstab_filename(), key_loc, 0, sizeof(key_loc));
 
     if (!strcmp(howarg, "wipe")) {
@@ -1178,7 +1564,8 @@
     }
     close(fd);
 
-    /* If doing inplace encryption, make sure the orig fs doesn't include the crypto footer */
+    /* If doing inplace encryption, make sure the orig fs doesn't include the crypto footer 
+	// ADAM PDE: not needed since inplace is disabled on /data     
     if ((how == CRYPTO_ENABLE_INPLACE) && (!strcmp(key_loc, KEY_IN_FOOTER))) {
         unsigned int fs_size_sec, max_fs_size_sec;
 
@@ -1189,7 +1576,7 @@
             SLOGE("Orig filesystem overlaps crypto footer region.  Cannot encrypt in place.");
             goto error_unencrypted;
         }
-    }
+    }*/
 
     /* Get a wakelock as this may take a while, and we don't want the
      * device to sleep on us.  We'll grab a partial wakelock, and if the UI
@@ -1200,6 +1587,7 @@
 
     /* Get the sdcard mount point */
     sd_mnt_point = getenv("EMULATED_STORAGE_SOURCE");
+     
     if (!sd_mnt_point) {
        sd_mnt_point = getenv("EXTERNAL_STORAGE");
     }
@@ -1261,41 +1649,39 @@
         goto error_shutting_down;
     }
 
-    /* Do extra work for a better UX when doing the long inplace encryption */
-    if (how == CRYPTO_ENABLE_INPLACE) {
-        /* Now that /data is unmounted, we need to mount a tmpfs
-         * /data, set a property saying we're doing inplace encryption,
-         * and restart the framework.
-         */
-        if (fs_mgr_do_tmpfs_mount(DATA_MNT_POINT)) {
-            goto error_shutting_down;
-        }
-        /* Tells the framework that inplace encryption is starting */
-        property_set("vold.encrypt_progress", "0");
-
-        /* restart the framework. */
-        /* Create necessary paths on /data */
-        if (prep_data_fs()) {
-            goto error_shutting_down;
-        }
-
-        /* Ugh, shutting down the framework is not synchronous, so until it
-         * can be fixed, this horrible hack will wait a moment for it all to
-         * shut down before proceeding.  Without it, some devices cannot
-         * restart the graphics services.
-         */
-        sleep(2);
-
-        /* startup service classes main and late_start */
-        property_set("vold.decrypt", "trigger_restart_min_framework");
-        SLOGD("Just triggered restart_min_framework\n");
-
-        /* OK, the framework is restarted and will soon be showing a
-         * progress bar.  Time to setup an encrypted mapping, and
-         * either write a new filesystem, or encrypt in place updating
-         * the progress bar as we work.
-         */
-    }
+    /* Do extra work for a better UX when doing the long encryption */
+    /* Now that /data is unmounted, we need to mount a tmpfs
+     * /data, set a property saying we're doing inplace encryption,
+     * and restart the framework.
+     */
+    if (fs_mgr_do_tmpfs_mount(DATA_MNT_POINT)) {
+        goto error_shutting_down;
+    }
+    /* Tells the framework that inplace encryption is starting */
+    property_set("vold.encrypt_progress", "0");
+
+    /* restart the framework. */
+    /* Create necessary paths on /data */
+    if (prep_data_fs()) {
+        goto error_shutting_down;
+    }
+
+    /* Ugh, shutting down the framework is not synchronous, so until it
+     * can be fixed, this horrible hack will wait a moment for it all to
+     * shut down before proceeding.  Without it, some devices cannot
+     * restart the graphics services.
+     */
+    sleep(2);
+
+    /* startup service classes main and late_start */
+    property_set("vold.decrypt", "trigger_restart_min_framework");
+    SLOGD("Just triggered restart_min_framework\n");
+
+    /* OK, the framework is restarted and will soon be showing a
+     * progress bar.  Time to setup an encrypted mapping, and
+     * either write a new filesystem, or encrypt in place updating
+     * the progress bar as we work.
+     */
 
     /* Start the actual work of making an encrypted filesystem */
     /* Initialize a crypt_mnt_ftr for the partition */
@@ -1306,7 +1692,10 @@
         crypt_ftr.fs_size = nr_sec;
     }
     crypt_ftr.flags |= CRYPT_ENCRYPTION_IN_PROGRESS;
-    strcpy((char *)crypt_ftr.crypto_type_name, "aes-cbc-essiv:sha256");
+    
+	/* ADAM PDE : Using XTS cipher */
+	strcpy((char *)crypt_ftr.crypto_type_name, "aes-xts-plain64");
+    //strcpy((char *)crypt_ftr.crypto_type_name, "aes-cbc-essiv:sha256");
 
     /* Make an encrypted master key */
     if (create_encrypted_random_key(passwd, master_key, salt)) {
@@ -1318,11 +1707,14 @@
     put_crypt_ftr_and_key(real_blkdev, &crypt_ftr, master_key, salt);
 
     decrypt_master_key(passwd, salt, master_key, decrypted_master_key);
-    create_crypto_blk_dev(&crypt_ftr, decrypted_master_key, real_blkdev, crypto_blkdev,
-                          "userdata");
+
 
     /* The size of the userdata partition, and add in the vold volumes below */
+    //ADAM PDE: added twice to account for 2-pass shred
     tot_encryption_size = crypt_ftr.fs_size;
+    tot_encryption_size += crypt_ftr.fs_size; 
+
+
 
     /* setup crypto mapping for all encryptable volumes handled by vold */
     for (i=0; i<num_vols; i++) {
@@ -1331,13 +1723,51 @@
             vol_list[i].crypt_ftr.fs_size = vol_list[i].size;
             create_crypto_blk_dev(&vol_list[i].crypt_ftr, decrypted_master_key,
                                   vol_list[i].blk_dev, vol_list[i].crypto_blkdev,
-                                  vol_list[i].label);
-            tot_encryption_size += vol_list[i].size;
-        }
-    }
+                                  vol_list[i].label, 0);
+            tot_encryption_size = (how == CRYPTO_ENABLE_INPLACE) ? tot_encryption_size + vol_list[i].size : tot_encryption_size;
+            //tot_encryption_size += vol_list[i].size;
+        }
+    }
+
+
+
+          
+    /* SHRED USERDATA VOLUME: create mapping w/ random key, encrypt in-place, delete mapping, repeat. */
+    urandom_fd = open("/dev/urandom", O_RDONLY);
+    read(urandom_fd, shred_key, sizeof(shred_key));
+    close(urandom_fd);
+
+    create_crypto_blk_dev(&crypt_ftr, shred_key, real_blkdev, crypto_blkdev,
+                  "userdata", 0);
+
+    rc = cryptfs_enable_inplace(crypto_blkdev, real_blkdev, crypt_ftr.fs_size,
+                            &cur_encryption_done, tot_encryption_size);
+
+    delete_crypto_blk_dev("userdata");
+
+    urandom_fd = open("/dev/urandom", O_RDONLY);
+    read(urandom_fd, shred_key, sizeof(shred_key));
+    close(urandom_fd);
+                      
+    create_crypto_blk_dev(&crypt_ftr, shred_key, real_blkdev, crypto_blkdev,
+                  "userdata", 0);
+
+    rc = cryptfs_enable_inplace(crypto_blkdev, real_blkdev, crypt_ftr.fs_size,
+                            &cur_encryption_done, tot_encryption_size);
+
+    delete_crypto_blk_dev("userdata");
+    
+    
+    
+    // create crypto mapping
+    create_crypto_blk_dev(&crypt_ftr, decrypted_master_key, real_blkdev, crypto_blkdev,
+                  "userdata", 0);
+                  
+    // create filesystem
+    cryptfs_enable_wipe(crypto_blkdev, crypt_ftr.fs_size, EXT4_FS);
+
 
     if (how == CRYPTO_ENABLE_WIPE) {
-        rc = cryptfs_enable_wipe(crypto_blkdev, crypt_ftr.fs_size, EXT4_FS);
         /* Encrypt all encryptable volumes handled by vold */
         if (!rc) {
             for (i=0; i<num_vols; i++) {
@@ -1348,8 +1778,6 @@
             }
         }
     } else if (how == CRYPTO_ENABLE_INPLACE) {
-        rc = cryptfs_enable_inplace(crypto_blkdev, real_blkdev, crypt_ftr.fs_size,
-                                    &cur_encryption_done, tot_encryption_size);
         /* Encrypt all encryptable volumes handled by vold */
         if (!rc) {
             for (i=0; i<num_vols; i++) {
@@ -1361,11 +1789,6 @@
                 }
             }
         }
-        if (!rc) {
-            /* The inplace routine never actually sets the progress to 100%
-             * due to the round down nature of integer division, so set it here */
-            property_set("vold.encrypt_progress", "100");
-        }
     } else {
         /* Shouldn't happen */
         SLOGE("cryptfs_enable: internal error, unknown option\n");
@@ -1384,6 +1807,10 @@
 
     if (! rc) {
         /* Success */
+
+        // The inplace routine never actually sets the progress to 100%
+        // due to the round down nature of integer division, so set it here
+        property_set("vold.encrypt_progress", "100");
 
         /* Clear the encryption in progres flag in the footer */
         crypt_ftr.flags &= ~CRYPT_ENCRYPTION_IN_PROGRESS;
@@ -1448,12 +1875,493 @@
     return -1;
 }
 
+
+/* ADAM PDE : Enable PDE crypto */
+int cryptfs_enable_pde(char *howarg, char *passwd, char *pde_passwd)
+{
+    int how = 0;
+    char crypto_blkdev[MAXPATHLEN], real_blkdev[MAXPATHLEN], sd_crypto_blkdev[MAXPATHLEN];
+    unsigned long nr_sec;
+    unsigned char master_key[KEY_LEN_BYTES], decrypted_master_key[KEY_LEN_BYTES];
+    unsigned char pde_master_key[KEY_LEN_BYTES], pde_decrypted_master_key[KEY_LEN_BYTES];
+    unsigned char salt[SALT_LEN], pde_salt[SALT_LEN];
+    int rc=-1, fd, i, ret;
+    int urandom_fd;
+    unsigned char shred_key[KEY_LEN_BYTES];
+    struct crypt_mnt_ftr crypt_ftr, sd_crypt_ftr;;
+    char tmpfs_options[PROPERTY_VALUE_MAX];
+    char encrypted_state[PROPERTY_VALUE_MAX];
+    char lockid[32] = { 0 };
+    char key_loc[PROPERTY_VALUE_MAX];
+    char fuse_sdcard[PROPERTY_VALUE_MAX];
+    char *sd_mnt_point;
+    char sd_blk_dev[256] = { 0 };
+    int num_vols;
+    struct volume_info *vol_list = 0;
+    off64_t cur_encryption_done=0, tot_encryption_size=0;
+    off64_t pde_size, off;
+    off64_t cur_blk, cln_blk;
+	unsigned int cnt;
+
+    property_get("ro.crypto.state", encrypted_state, "");
+    if (strcmp(encrypted_state, "unencrypted")) {
+        SLOGE("Device is already running encrypted, aborting");
+        goto error_unencrypted;
+    }
+
+	// If this device has a persistent log partition, mount a tmpfs
+	if (!access("/devlog", F_OK)) {
+		wait_and_unmount("/devlog");
+		mount("tmpfs", "/devlog", "tmpfs", MS_NOATIME | MS_NOSUID | MS_NODEV, "size=8m");  
+		// fs_mgr_do_tmpfs_mount("/devlog");
+	}
+
+    fs_mgr_get_crypt_info(get_fstab_filename(), key_loc, 0, sizeof(key_loc));
+
+    if (!strcmp(howarg, "wipe")) {
+      how = CRYPTO_ENABLE_WIPE;
+    } else if (! strcmp(howarg, "inplace")) {
+      how = CRYPTO_ENABLE_INPLACE;
+    } else {
+      /* Shouldn't happen, as CommandListener vets the args */
+      goto error_unencrypted;
+    }
+
+    fs_mgr_get_crypt_info(get_fstab_filename(), 0, real_blkdev, sizeof(real_blkdev));
+
+    /* Get the size of the real block device */
+    fd = open(real_blkdev, O_RDONLY);
+    if ( (nr_sec = get_blkdev_size(fd)) == 0) {
+        SLOGE("Cannot get size of block device %s\n", real_blkdev);
+        goto error_unencrypted;
+    }
+    close(fd);
+
+    /* If doing inplace encryption, make sure the orig fs doesn't include the crypto footer
+	// ADAM PDE: not needed since inplace is disabled on /data      
+    if ((how == CRYPTO_ENABLE_INPLACE) && (!strcmp(key_loc, KEY_IN_FOOTER))) {
+        unsigned int fs_size_sec, max_fs_size_sec;
+
+        fs_size_sec = get_fs_size(real_blkdev);
+        max_fs_size_sec = nr_sec - (CRYPT_FOOTER_OFFSET / 512);
+
+        if (fs_size_sec > max_fs_size_sec) {
+            SLOGE("Orig filesystem overlaps crypto footer region.  Cannot encrypt in place.");
+            goto error_unencrypted;
+        }
+    }*/
+
+    /* Get a wakelock as this may take a while, and we don't want the
+     * device to sleep on us.  We'll grab a partial wakelock, and if the UI
+     * wants to keep the screen on, it can grab a full wakelock.
+     */
+    snprintf(lockid, sizeof(lockid), "enablecrypto%d", (int) getpid());
+    acquire_wake_lock(PARTIAL_WAKE_LOCK, lockid);
+
+    /* Get the sdcard mount point */
+    sd_mnt_point = getenv("EMULATED_STORAGE_SOURCE");
+       
+    if (!sd_mnt_point) {
+       sd_mnt_point = getenv("EXTERNAL_STORAGE");
+    }
+    if (!sd_mnt_point) {
+        sd_mnt_point = "/mnt/sdcard";
+    }
+
+    num_vols=vold_getNumDirectVolumes();
+    vol_list = malloc(sizeof(struct volume_info) * num_vols);
+    vold_getDirectVolumeList(vol_list);
+
+    for (i=0; i<num_vols; i++) {
+        if (should_encrypt(&vol_list[i])) {
+            fd = open(vol_list[i].blk_dev, O_RDONLY);
+            if ( (vol_list[i].size = get_blkdev_size(fd)) == 0) {
+                SLOGE("Cannot get size of block device %s\n", vol_list[i].blk_dev);
+                goto error_unencrypted;
+            }
+            close(fd);
+
+            ret=vold_disableVol(vol_list[i].label);
+            if ((ret < 0) && (ret != UNMOUNT_NOT_MOUNTED_ERR)) {
+                /* -2 is returned when the device exists but is not currently mounted.
+                 * ignore the error and continue. */
+                SLOGE("Failed to unmount volume %s\n", vol_list[i].label);
+                goto error_unencrypted;
+            }
+        }
+    }
+
+    /* The init files are setup to stop the class main and late start when
+     * vold sets trigger_shutdown_framework.
+     */
+    property_set("vold.decrypt", "trigger_shutdown_framework");
+    SLOGD("Just asked init to shut down class main\n");
+
+    if (vold_unmountAllAsecs()) {
+        /* Just report the error.  If any are left mounted,
+         * umounting /data below will fail and handle the error.
+         */
+        SLOGE("Error unmounting internal asecs");
+    }
+
+    property_get("ro.crypto.fuse_sdcard", fuse_sdcard, "");
+    if (!strcmp(fuse_sdcard, "true")) {
+        /* This is a device using the fuse layer to emulate the sdcard semantics
+         * on top of the userdata partition.  vold does not manage it, it is managed
+         * by the sdcard service.  The sdcard service was killed by the property trigger
+         * above, so just unmount it now.  We must do this _AFTER_ killing the framework,
+         * unlike the case for vold managed devices above.
+         */
+        if (wait_and_unmount(sd_mnt_point)) {
+            goto error_shutting_down;
+        }
+    }
+
+    /* Now unmount the /data partition. */
+    if (wait_and_unmount(DATA_MNT_POINT)) {
+        goto error_shutting_down;
+    }
+
+    /* Do extra work for a better UX when doing the long inplace encryption */
+    /* Now that /data is unmounted, we need to mount a tmpfs
+     * /data, set a property saying we're doing inplace encryption,
+     * and restart the framework.
+     */
+    if (fs_mgr_do_tmpfs_mount(DATA_MNT_POINT)) {
+        goto error_shutting_down;
+    }
+    /* Tells the framework that inplace encryption is starting */
+    property_set("vold.encrypt_progress", "0");
+
+    /* restart the framework. */
+    /* Create necessary paths on /data */
+    if (prep_data_fs()) {
+        goto error_shutting_down;
+    }
+
+
+    /* Ugh, shutting down the framework is not synchronous, so until it
+     * can be fixed, this horrible hack will wait a moment for it all to
+     * shut down before proceeding.  Without it, some devices cannot
+     * restart the graphics services.
+     */
+    sleep(2);
+
+    /* startup service classes main and late_start */
+    property_set("vold.decrypt", "trigger_restart_min_framework");
+    SLOGD("Just triggered restart_min_framework\n");
+
+    /* OK, the framework is restarted and will soon be showing a
+     * progress bar.  Time to setup an encrypted mapping, and
+     * either write a new filesystem, or encrypt in place updating
+     * the progress bar as we work.
+     */
+         
+    /* Start the actual work of making an encrypted filesystem */
+    /* Initialize a crypt_mnt_ftr for the partition */
+    cryptfs_init_crypt_mnt_ftr(&crypt_ftr);
+    if (!strcmp(key_loc, KEY_IN_FOOTER)) {
+        crypt_ftr.fs_size = nr_sec - (CRYPT_FOOTER_OFFSET / 512);
+    } else {
+        crypt_ftr.fs_size = nr_sec;
+    }
+    crypt_ftr.flags |= CRYPT_ENCRYPTION_IN_PROGRESS;
+    
+	/* ADAM PDE : Using XTS cipher */
+	strcpy((char *)crypt_ftr.crypto_type_name, "aes-xts-plain64");
+    //strcpy((char *)crypt_ftr.crypto_type_name, "aes-cbc-essiv:sha256");
+
+    /* Make an encrypted master key */
+    if (create_encrypted_random_key(passwd, master_key, salt)) {
+        SLOGE("Cannot create encrypted master key\n");
+        goto error_unencrypted;
+    }
+
+    /* Write the key to the end of the partition */
+    put_crypt_ftr_and_key(real_blkdev, &crypt_ftr, master_key, salt);
+
+    decrypt_master_key(passwd, salt, master_key, decrypted_master_key);
+    
+    //create_crypto_blk_dev(&crypt_ftr, decrypted_master_key, real_blkdev, crypto_blkdev,
+    //                      "userdata", 0);
+
+    /* The size of the userdata partition, and add in the vold volumes below */
+    //ADAM PDE: added twice to account for 2-pass shred
+    tot_encryption_size = crypt_ftr.fs_size;
+    tot_encryption_size += crypt_ftr.fs_size;
+
+
+    /* setup crypto mapping for all encryptable volumes handled by vold */
+    for (i=0; i<num_vols; i++) {
+        if (should_encrypt(&vol_list[i])) {
+            vol_list[i].crypt_ftr = crypt_ftr; /* gotta love struct assign */
+            vol_list[i].crypt_ftr.fs_size = vol_list[i].size;
+            create_crypto_blk_dev(&vol_list[i].crypt_ftr, decrypted_master_key,
+                                  vol_list[i].blk_dev, vol_list[i].crypto_blkdev,
+                                  vol_list[i].label, 0);
+            tot_encryption_size = (how == CRYPTO_ENABLE_INPLACE) ? tot_encryption_size + vol_list[i].size : tot_encryption_size;
+        }
+    }
+
+/* SHRED USERDATA VOLUME: create mapping w/ random key, encrypt in-place, delete mapping, repeat. */
+    urandom_fd = open("/dev/urandom", O_RDONLY);
+    read(urandom_fd, shred_key, sizeof(shred_key));
+    close(urandom_fd);
+
+    create_crypto_blk_dev(&crypt_ftr, shred_key, real_blkdev, crypto_blkdev,
+                  "userdata", 0);
+
+    rc = cryptfs_enable_inplace(crypto_blkdev, real_blkdev, crypt_ftr.fs_size,
+                            &cur_encryption_done, tot_encryption_size);
+
+    delete_crypto_blk_dev("userdata");
+
+    urandom_fd = open("/dev/urandom", O_RDONLY);
+    read(urandom_fd, shred_key, sizeof(shred_key));
+    close(urandom_fd);
+                      
+    create_crypto_blk_dev(&crypt_ftr, shred_key, real_blkdev, crypto_blkdev,
+                  "userdata", 0);
+
+    rc = cryptfs_enable_inplace(crypto_blkdev, real_blkdev, crypt_ftr.fs_size,
+                            &cur_encryption_done, tot_encryption_size);
+
+    delete_crypto_blk_dev("userdata");
+  
+// ************  END OF SHRED LOGIC ****************************************
+    
+    
+    // *****************************************************************
+    /* ADAM PDE: HIDDEN VOLUME */
+    // *****************************************************************
+    
+    /* ADAM PDE : create pde key */
+    if (create_encrypted_random_key(pde_passwd, pde_master_key, pde_salt)) {
+	    //SLOGE("Cannot create encrypted PDE master key\n");
+	    goto error_unencrypted;
+    }
+    
+    // ADAM PDE: decrypt PDE key     
+    decrypt_master_key(pde_passwd, salt, pde_master_key, pde_decrypted_master_key);
+    
+    /* ADAM PDE : calculate PDE size */
+    pde_size = calc_hidden_size(salt, crypt_ftr.fs_size);
+
+    /* ADAM PDE : open real block device */
+    if ( (fd = open(real_blkdev, O_RDWR)) < 0) {
+      //SLOGE("Cannot open real block device %s\n", vol_list[i].blk_dev);
+      goto error_unencrypted;
+    }
+
+    /* ADAM PDE : calculate PDE offset */    
+    off = (crypt_ftr.fs_size - pde_size);
+    
+
+    // We need 4 clean blocks in a row for the key and FS header
+    // walk the blocks until we have 4 clean blocks
+    do {
+    
+        // get blk_num of the current offset
+        cur_blk = ((off * 512) / 4096);
+        
+        for (i=0; i<4; i++) {
+        
+            if ((cln_blk = cryptfs_is_badblk(cur_blk))) {
+                // block is bad, cln_blk has the index of the next clean block
+                
+                // adjust offset to cln_blk
+                off = (cln_blk * 4096) / 512;
+                
+                // adjust pde volume size to account for new offset
+                pde_size = crypt_ftr.fs_size - off;
+                
+                // continue while loop if we found a bad block
+                break;
+                
+            } // else block was clean
+        
+        }
+    
+    } while(cln_blk);
+    
+    
+    /* ADAM PDE: seek to clean offset in real block device */
+    if (lseek64(fd, off * 512, SEEK_SET) == -1) {
+      //SLOGE("Cannot seek to real block device PDE Key\n");
+      goto error_unencrypted;
+    }
+    
+    /* ADAM PDE: write key to real block device at clean PDE offset */
+    if ((cnt = write(fd, pde_master_key, sizeof(pde_master_key))) != sizeof(pde_master_key)) {
+        //SLOGE("Cannot write real block device PDE key\n");
+        goto error_unencrypted;
+    }
+
+    // ADAM PDE: close real block device file descriptor
+    close(fd);
+
+    // ADAM PDE: adjust off to off+8 to account for hidden volume key
+    off += 8;
+
+    // setup crypto mapping for pde volume
+    create_crypto_blk_dev(&crypt_ftr, pde_decrypted_master_key, real_blkdev, crypto_blkdev,
+        "pde", off);
+
+    /* ADAM PDE : Format/encrypt hidden volume with bad-block marking */
+    rc = cryptfs_calc_badblk(crypto_blkdev, off, crypt_ftr.fs_size);			      
+    // rc = cryptfs_enable_wipe(crypto_blkdev, pde_size - 1, EXT4_FS);
+
+    /* ADAM PDE : Undo the dm-crypt mapping for hidden volume */
+    delete_crypto_blk_dev("pde");
+    
+    
+    // *****************************************************************
+    /* ADAM PDE: OUTER VOLUME */
+    // *****************************************************************
+    
+    // create outer crypto mapping
+    create_crypto_blk_dev(&crypt_ftr, decrypted_master_key, real_blkdev, crypto_blkdev,
+                  "userdata", 0);
+                  
+    // create outer filesystem
+    cryptfs_enable_wipe(crypto_blkdev, crypt_ftr.fs_size, EXT4_FS);
+
+
+    // Undo the dm-crypt mappings for outer volume
+    delete_crypto_blk_dev("userdata");
+
+
+
+
+
+
+    /* ADAM PDE: now resume encrypting any other block devices handled by vold */
+    if (how == CRYPTO_ENABLE_WIPE) {
+        /* Encrypt all encryptable volumes handled by vold */
+        if (!rc) {
+            for (i=0; i<num_vols; i++) {
+                if (should_encrypt(&vol_list[i])) {
+                    rc = cryptfs_enable_wipe(vol_list[i].crypto_blkdev,
+                                             vol_list[i].crypt_ftr.fs_size, FAT_FS);
+                }
+            }
+        }
+    } else if (how == CRYPTO_ENABLE_INPLACE) {
+        /* Encrypt all encryptable volumes handled by vold */
+        if (!rc) {
+            for (i=0; i<num_vols; i++) {
+                if (should_encrypt(&vol_list[i])) {
+                    rc = cryptfs_enable_inplace(vol_list[i].crypto_blkdev,
+                                                vol_list[i].blk_dev,
+                                                vol_list[i].crypt_ftr.fs_size,
+                                                &cur_encryption_done, tot_encryption_size);
+                }
+            }
+        }
+    } else {
+        /* Shouldn't happen */
+        SLOGE("cryptfs_enable: internal error, unknown option\n");
+        goto error_unencrypted;
+    }
+
+    /* Undo the dm-crypt mapping whether we succeed or not */
+    //delete_crypto_blk_dev("userdata");
+    for (i=0; i<num_vols; i++) {
+        if (should_encrypt(&vol_list[i])) {
+            delete_crypto_blk_dev(vol_list[i].label);
+        }
+    }
+
+   
+    /* The shred routine never actually sets the progress to 100%
+     * due to the round down nature of integer division, so set it here */
+    property_set("vold.encrypt_progress", "100");
+     
+    free(vol_list);
+
+    if (! rc) {
+        /* Success */
+
+        /* Clear the encryption in progres flag in the footer */
+        crypt_ftr.flags &= ~CRYPT_ENCRYPTION_IN_PROGRESS;
+        put_crypt_ftr_and_key(real_blkdev, &crypt_ftr, 0, 0);
+
+        sleep(2); /* Give the UI a chance to show 100% progress */
+        android_reboot(ANDROID_RB_RESTART, 0, 0);
+    } else {
+        char value[PROPERTY_VALUE_MAX];
+
+        property_get("ro.vold.wipe_on_crypt_fail", value, "0");
+        if (!strcmp(value, "1")) {
+            /* wipe data if encryption failed */
+            SLOGE("encryption failed - rebooting into recovery to wipe data\n");
+            mkdir("/cache/recovery", 0700);
+            int fd = open("/cache/recovery/command", O_RDWR|O_CREAT|O_TRUNC, 0600);
+            if (fd >= 0) {
+                write(fd, "--wipe_data", strlen("--wipe_data") + 1);
+                close(fd);
+            } else {
+                SLOGE("could not open /cache/recovery/command\n");
+            }
+            android_reboot(ANDROID_RB_RESTART2, 0, "recovery");
+        } else {
+            /* set property to trigger dialog */
+            property_set("vold.encrypt_progress", "error_partially_encrypted");
+            release_wake_lock(lockid);
+        }
+        return -1;
+    }
+
+    /* hrm, the encrypt step claims success, but the reboot failed.
+     * This should not happen.
+     * Set the property and return.  Hope the framework can deal with it.
+     */
+    property_set("vold.encrypt_progress", "error_reboot_failed");
+    release_wake_lock(lockid);
+    return rc;
+
+error_unencrypted:
+    free(vol_list);
+    property_set("vold.encrypt_progress", "error_not_encrypted");
+    if (lockid[0]) {
+        release_wake_lock(lockid);
+    }
+    return -1;
+
+error_shutting_down:
+    /* we failed, and have not encrypted anthing, so the users's data is still intact,
+     * but the framework is stopped and not restarted to show the error, so it's up to
+     * vold to restart the system.
+     */
+    SLOGE("Error enabling encryption after framework is shutdown, no data changed, restarting system");
+    android_reboot(ANDROID_RB_RESTART, 0, 0);
+
+    /* shouldn't get here */
+    property_set("vold.encrypt_progress", "error_shutting_down");
+    free(vol_list);
+    if (lockid[0]) {
+        release_wake_lock(lockid);
+    }
+    return -1;
+}
+
+/* ************************************************************************/
+
+
+
+
+
+
+
+
+
 int cryptfs_changepw(char *newpw)
 {
     struct crypt_mnt_ftr crypt_ftr;
     unsigned char encrypted_master_key[KEY_LEN_BYTES], decrypted_master_key[KEY_LEN_BYTES];
     unsigned char salt[SALT_LEN];
     char real_blkdev[MAXPATHLEN];
+    int fd, cnt;
 
     /* This is only allowed after we've successfully decrypted the master key */
     if (! master_key_saved) {
@@ -1466,17 +2374,46 @@
         SLOGE("Can't find real blkdev");
         return -1;
     }
-
-    /* get key */
-    if (get_crypt_ftr_and_key(real_blkdev, &crypt_ftr, encrypted_master_key, salt)) {
-      SLOGE("Error getting crypt footer and key");
-      return -1;
-    }
-
-    encrypt_master_key(newpw, salt, saved_master_key, encrypted_master_key);
-
-    /* save the key */
-    put_crypt_ftr_and_key(real_blkdev, &crypt_ftr, encrypted_master_key, salt);
+    
+	/* get footer */
+	if (get_crypt_ftr_and_key(real_blkdev, &crypt_ftr, encrypted_master_key, salt)) {
+	  SLOGE("Error getting crypt footer and key");
+	  return -1;
+	}
+
+	// Wrap encryption key with new password
+	encrypt_master_key(newpw, salt, saved_master_key, encrypted_master_key);
+
+	/* ADAM PDE: check if we are mounted in outer or hidden volume */
+	if (g_pdeoff) {		// CASE: HIDDEN VOLUME
+
+		// Open real block device for writing
+		if ( (fd = open(real_blkdev, O_RDWR)) < 0) {
+		  //SLOGE("Cannot open real block device\n");
+		  return -1;
+		}
+		
+		// Seek to PDE key offset
+        if (lseek64(fd, g_pdeoff*512, SEEK_SET) == -1) {
+          //SLOGE("Cannot seek to real block device PDE Key\n");
+          return -1;
+        }
+	
+		// Store key at PDE offset
+		if ((cnt = write(fd, encrypted_master_key, sizeof(encrypted_master_key))) != sizeof(encrypted_master_key)) {
+		    //SLOGE("Cannot write real block device PDE key\n");
+		    return -1;
+		}
+		
+		// close real block device
+        close(fd);
+	
+	} else {  // CASE: OUTER VOLUME
+
+		/* save the key */
+		put_crypt_ftr_and_key(real_blkdev, &crypt_ftr, encrypted_master_key, salt);
+	
+	}
 
     return 0;
 }
     
 
--- system/vold/cryptfs.h
+++ system/vold/cryptfs.h
@@ -12,6 +12,41 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *  
+ * 
+ * This file was modified from the original project to implement the Mobiflage
+ * plausible deniable storage encryption functionality by Adam Skillen.
+ *   
+ * Copyright (C) 2013 Adam Skillen
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *      This product includes software developed by Adam Skillen
+ * 4. Neither the name of Concordia University, Mobiflage, nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *  
  */
 
 /* This structure starts 16,384 bytes before the end of a hardware
@@ -83,6 +118,7 @@
                            char *crypto_dev_path, unsigned int max_pathlen,
                            int *new_major, int *new_minor);
   int cryptfs_revert_volume(const char *label);
+  int cryptfs_enable_pde(char *flag, char *passwd, char *pde_passwd);
 #ifdef __cplusplus
 }
 #endif
 
 
--- build/target/product/core.mk
+++ build/target/product/core.mk
@@ -138,6 +138,11 @@
     property_contexts \
     mac_permissions.xml
     
+# Mobiflage packages:
+PRODUCT_PACKAGES += \
+    mke2fs\
+    tune2fs
+
 # host-only dependencies
 ifeq ($(WITH_HOST_DALVIK),true)
     PRODUCT_PACKAGES += \


--- frameworks/base/core/java/com/android/internal/widget/LockPatternUtils.java
+++ frameworks/base/core/java/com/android/internal/widget/LockPatternUtils.java
@@ -617,7 +617,8 @@
             if (password != null) {
                 if (userHandle == UserHandle.USER_OWNER) {
                     // Update the encryption password.
-                    updateEncryptionPassword(password);
+                    // ADAM PDE: Disabled so unlock pwd and preboot pwd are separated
+                    // updateEncryptionPassword(password);
 
                     // Update the keystore password
                     keyStore.password(password);
